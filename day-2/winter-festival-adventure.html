<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winter Festival Adventure ‚ùÑÔ∏è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }

        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #4fc3f7, 0 0 20px #81d4fa;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #4fc3f7, 0 0 20px #81d4fa; }
            to { text-shadow: 0 0 20px #4fc3f7, 0 0 40px #81d4fa, 0 0 60px #4fc3f7; }
        }

        #game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            margin-bottom: 20px;
        }

        #story-panel {
            max-width: 800px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        #story-text {
            font-size: 1.1rem;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: center;
        }

        .controls {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #81d4fa;
        }

        /* Snowflakes background */
        .snowflake {
            position: fixed;
            top: -10px;
            z-index: 1;
            color: white;
            font-size: 1em;
            font-family: Arial, sans-serif;
            text-shadow: 0 0 5px #ffffff;
            pointer-events: none;
            animation: fall linear infinite;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh);
            }
        }

        .instructions {
            text-align: center;
            font-size: 0.85rem;
            color: #b3e5fc;
            margin-top: 10px;
        }

        /* Settings Menu */
        #settings-menu {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        #settings-toggle {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            transition: all 0.3s ease;
            position: relative;
        }

        #settings-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: rotate(90deg);
            box-shadow: 0 12px 40px rgba(79, 195, 247, 0.4);
        }

        #settings-toggle.active {
            background: rgba(79, 195, 247, 0.3);
            border-color: #4fc3f7;
            transform: rotate(90deg);
        }

        #settings-panel {
            position: absolute;
            top: 60px;
            right: 0;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            min-width: 250px;
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        #settings-panel.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section h3 {
            font-size: 0.95rem;
            margin-bottom: 12px;
            color: #81d4fa;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .music-btn {
            background: rgba(79, 195, 247, 0.3);
            border: 2px solid #4fc3f7;
            color: #ffffff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .music-btn:hover {
            background: rgba(79, 195, 247, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
        }

        .music-btn:active {
            transform: translateY(0);
        }

        .music-btn.playing {
            background: rgba(102, 187, 106, 0.4);
            border-color: #66bb6a;
        }

        #volume-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        #volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .volume-label {
            font-size: 0.75rem;
            color: #b3e5fc;
            display: flex;
            justify-content: space-between;
        }

        .music-indicator {
            display: inline-block;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .keyboard-hint {
            font-size: 0.7rem;
            color: #81d4fa;
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        /* Mobile Touch Controls */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        @media (max-width: 768px), (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }

        .dpad-container {
            position: relative;
            width: 150px;
            height: 150px;
        }

        .dpad-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(79, 195, 247, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid #4fc3f7;
            border-radius: 10px;
            color: #ffffff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: none;
            transition: all 0.1s ease;
            box-shadow: 0 4px 12px rgba(31, 38, 135, 0.3);
        }

        .dpad-button:active, .dpad-button.active {
            background: rgba(79, 195, 247, 0.6);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.6);
        }

        .dpad-up {
            top: 0;
            left: 50px;
        }

        .dpad-down {
            bottom: 0;
            left: 50px;
        }

        .dpad-left {
            top: 50px;
            left: 0;
        }

        .dpad-right {
            top: 50px;
            right: 0;
        }

        .dpad-center {
            top: 50px;
            left: 50px;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        .mobile-restart-btn {
            background: rgba(239, 83, 80, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid #ef5350;
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(135, 0.3);
        }

        .mobile-restart-btn:active {
            background: rgba(239, 83, 80, 0.6);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(239, 83, 80, 0.6);
        }

        .portal-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(79, 195, 247, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: bold;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .portal-hint.show {
            opacity: 1;
        }

    </style>
</head>
<body>
    <h1>‚ùÑÔ∏è Winter Festival Adventure ‚ùÑÔ∏è</h1>
    
    <!-- Settings Menu -->
    <div id="settings-menu">
        <button id="settings-toggle" title="Settings">‚öôÔ∏è</button>
        <div id="settings-panel">
            <div class="settings-section">
                <h3>
                    <span id="music-icon">üéµ</span>
                    Music
                </h3>
                <button id="toggle-music" class="music-btn">
                    <span id="play-icon">‚ñ∂Ô∏è</span>
                    <span id="music-status">Play</span>
                </button>
                <div id="volume-control">
                    <div class="volume-label">
                        <span>Volume</span>
                        <span id="volume-value">70%</span>
                    </div>
                    <input type="range" id="volume-slider" min="0" max="100" value="70">
                </div>
                <div class="keyboard-hint">Press M to toggle</div>
            </div>
            
            <div class="settings-section">
                <h3>
                    <span>üíæ</span>
                    Game
                </h3>
                <div id="save-info" style="font-size: 0.75rem; color: #b3e5fc; margin-bottom: 10px; text-align: center;">
                    No save data
                </div>
                <button id="delete-save" class="music-btn" style="border-color: #ef5350; display: none;">
                    <span>üóëÔ∏è</span>
                    <span>Delete Save</span>
                </button>
            </div>
        </div>
    </div>
    
    <div id="game-container">
        <div id="phaser-game"></div>
    </div>

    <div id="story-panel">
        <div id="story-text">
            Welcome to the Winter Festival! The magical Festival Star has gone missing, 
            and the celebration cannot begin without it. Use the arrow keys to move your elf 
            and walk into a portal to begin your adventure. Get close and it will auto-enter!
        </div>
        <div class="instructions">
            üéÆ Arrow Keys: Move | Walk to Portal (auto-enters) | SPACE: Quick Enter | R: Restart
        </div>
    </div>
    
    <!-- Mobile Touch Controls -->
    <div id="mobile-controls">
        <div class="dpad-container">
            <div class="dpad-button dpad-up" id="btn-up">‚¨ÜÔ∏è</div>
            <div class="dpad-button dpad-down" id="btn-down">‚¨áÔ∏è</div>
            <div class="dpad-button dpad-left" id="btn-left">‚¨ÖÔ∏è</div>
            <div class="dpad-button dpad-right" id="btn-right">‚û°Ô∏è</div>
            <div class="dpad-center"></div>
        </div>
        <button class="mobile-restart-btn" id="mobile-restart">üîÑ Restart</button>
    </div>
    
    <!-- Portal Proximity Hint -->
    <div id="portal-hint" class="portal-hint">
        üìç Near portal! Walk closer to enter
    </div>

    <!-- Magic Snowflakes Library -->
    <script type="module">
        import { Snowflakes } from 'https://cdn.jsdelivr.net/npm/magic-snowflakes@6.0.0/dist/snowflakes.esm.min.js';
        
        // Create background snowflakes
        const snowflakes = new Snowflakes({
            count: 50,
            minSize: 8,
            maxSize: 18,
            speed: 1.5,
            wind: true,
            rotation: true,
            color: '#ffffff'
        });
    </script>

    <!-- Main Game Script with Phaser.js -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script>
        // Phaser is now available globally
        const Phaser = window.Phaser;

        // Save Manager Class
        class SaveManager {
            constructor() {
                this.saveKey = 'winterFestivalSaveData';
                this.statsKey = 'winterFestivalStats';
            }
            
            saveGame(sceneKey, playerX, playerY) {
                const saveData = {
                    currentScene: sceneKey,
                    playerPosition: { x: playerX, y: playerY },
                    timestamp: Date.now(),
                    sceneName: this.getSceneName(sceneKey)
                };
                
                console.log('=== SAVE GAME DEBUG ===');
                console.log('Saving game:', saveData);
                console.log('saveKey:', this.saveKey);
                
                try {
                    localStorage.setItem(this.saveKey, JSON.stringify(saveData));
                    console.log('localStorage.setItem() completed');
                    
                    // Verify the save was written
                    const verification = localStorage.getItem(this.saveKey);
                    console.log('Verification read from localStorage:', verification);
                    
                    if (verification) {
                        console.log('‚úÖ Save successfully written and verified!');
                    } else {
                        console.error('‚ùå Save write failed - verification returned null');
                    }
                } catch (e) {
                    console.error('‚ùå localStorage.setItem() threw error:', e);
                }
                
                // Update stats
                this.updateStats(sceneKey);
                
                return saveData;
            }
            
            loadGame() {
                console.log('=== loadGame() called ===');
                console.log('Looking for key:', this.saveKey);
                const savedData = localStorage.getItem(this.saveKey);
                console.log('localStorage.getItem() returned:', savedData);
                console.log('Type:', typeof savedData);
                console.log('Truthy?', !!savedData);
                
                if (!savedData) {
                    console.log('‚ùå No saved data found, returning null');
                    return null;
                }
                
                try {
                    const parsed = JSON.parse(savedData);
                    console.log('‚úÖ Successfully parsed:', parsed);
                    return parsed;
                } catch (e) {
                    console.error('‚ùå Failed to parse save data:', e);
                    return null;
                }
            }
            
            deleteSave() {
                console.log('=== deleteSave() called ===');
                console.log('TIMESTAMP:', new Date().toISOString());
                console.trace('Call stack:');
                
                // Check if save exists before deleting
                const existingData = localStorage.getItem(this.saveKey);
                console.log('Data being deleted:', existingData);
                
                // Actually delete the save
                localStorage.removeItem(this.saveKey);
                console.log('‚úÖ Save deleted from localStorage');
                
                // Verify deletion
                const verification = localStorage.getItem(this.saveKey);
                console.log('Post-delete verification:', verification);
            }
            
            hasSave() {
                return localStorage.getItem(this.saveKey) !== null;
            }
            
            updateStats(sceneKey) {
                let stats = this.getStats();
                
                // Track visited scenes
                if (!stats.visitedScenes.includes(sceneKey)) {
                    stats.visitedScenes.push(sceneKey);
                }
                
                // Track completed endings
                const storyNode = storyData[sceneKey];
                if (storyNode && storyNode.isEnding) {
                    const endingId = `${sceneKey}_${storyNode.endingType}`;
                    if (!stats.completedEndings.includes(endingId)) {
                        stats.completedEndings.push(endingId);
                    }
                }
                
                // Update play count
                stats.playCount++;
                stats.lastPlayed = Date.now();
                
                localStorage.setItem(this.statsKey, JSON.stringify(stats));
            }
            
            getStats() {
                const statsData = localStorage.getItem(this.statsKey);
                if (!statsData) {
                    return {
                        visitedScenes: [],
                        completedEndings: [],
                        playCount: 0,
                        lastPlayed: null
                    };
                }
                
                try {
                    return JSON.parse(statsData);
                } catch (e) {
                    console.error('Failed to load stats:', e);
                    return {
                        visitedScenes: [],
                        completedEndings: [],
                        playCount: 0,
                        lastPlayed: null
                    };
                }
            }
            
            getSceneName(sceneKey) {
                const sceneNames = {
                    'start': 'Festival Entrance',
                    'clockTower': 'Clock Tower',
                    'woods': 'Whispering Woods',
                    'magician': "Magician's Tent",
                    'trustSprite': 'Victory: Faith Rewarded',
                    'healFox': 'Victory: Compassion Triumphs',
                    'acceptDeal': 'Victory: Wise Negotiation',
                    'offerHonor': 'Victory: Guardian of Festival',
                    'demandStar': 'Defeat: Trust Lost',
                    'rushCave': 'Defeat: Hasty Decision'
                };
                
                return sceneNames[sceneKey] || sceneKey;
            }
            
            getTimeSince(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;
                
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                
                if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
                if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                return 'Just now';
            }
        }
        
        // Initialize Save Manager and make it globally available
        const saveManager = new SaveManager();
        window.saveManager = saveManager;
        
        // DIAGNOSTIC TEST - Check localStorage on page load
        console.log('=== DIAGNOSTIC TEST ===');
        console.log('localStorage available?', typeof localStorage !== 'undefined');
        try {
            localStorage.setItem('test', 'value');
            console.log('localStorage.setItem() works:', localStorage.getItem('test') === 'value');
            localStorage.removeItem('test');
        } catch (e) {
            console.error('localStorage is BLOCKED or DISABLED:', e);
        }
        console.log('All localStorage keys:', Object.keys(localStorage));
        console.log('winterFestivalSaveData exists?', localStorage.getItem('winterFestivalSaveData'));
        console.log('======================');

        // Story data structure
        const storyData = {
            start: {
                text: "The Festival Star has vanished! Three mysterious paths have appeared. Which will you choose?",
                portals: [
                    { x: 200, y: 300, color: 0x4fc3f7, label: "Clock Tower", next: "clockTower" },
                    { x: 400, y: 300, color: 0x66bb6a, label: "Whispering Woods", next: "woods" },
                    { x: 600, y: 300, color: 0xba68c8, label: "Magician's Tent", next: "magician" }
                ]
            },
            clockTower: {
                text: "At the ancient Clock Tower, a shimmering sprite appears. 'I know where the Star is,' she whispers, 'but I need your trust.' Will you trust her completely, or demand proof first?",
                portals: [
                    { x: 300, y: 300, color: 0x66bb6a, label: "Trust the Sprite", next: "trustSprite" },
                    { x: 500, y: 300, color: 0xef5350, label: "Demand the Star", next: "demandStar" }
                ]
            },
            woods: {
                text: "In the Whispering Woods, you find an injured silver fox with glowing eyes. 'Help me,' it pleads, 'and I will guide you to the Star.' But you also see a cave entrance that pulses with magical light...",
                portals: [
                    { x: 300, y: 300, color: 0x66bb6a, label: "Heal the Fox", next: "healFox" },
                    { x: 500, y: 300, color: 0xef5350, label: "Rush to Cave", next: "rushCave" }
                ]
            },
            magician: {
                text: "The Magician's tent shimmers with starlight. Inside, a mysterious figure offers you a deal: 'I can reveal the Star's location, but you must promise me something in return.' Will you accept the deal or offer something else?",
                portals: [
                    { x: 300, y: 300, color: 0x66bb6a, label: "Accept the Deal", next: "acceptDeal" },
                    { x: 500, y: 300, color: 0x66bb6a, label: "Offer Your Honor", next: "offerHonor" }
                ]
            },
            // Good Endings
            trustSprite: {
                text: "The sprite's eyes fill with tears of joy. 'You trusted me when others wouldn't,' she says. She transforms into a radiant guardian angel and leads you to the Star hidden in the clock's mechanism. Your faith has saved the Festival! ‚≠ê",
                isEnding: true,
                endingType: "good"
            },
            healFox: {
                text: "The fox's wounds close as you tend to them with magical winter herbs. 'You have a kind heart,' it says, transforming into a Forest Spirit. 'The Star fell into my realm. I've been protecting it!' The fox leads you to the glowing Star nestled in snow. Compassion saves the day! ‚≠ê",
                isEnding: true,
                endingType: "good"
            },
            acceptDeal: {
                text: "The Magician smiles warmly. 'You were wise to trust in negotiation. The deal is simple: spread joy at the Festival.' The tent vanishes, revealing the Star floating above. The Magician was testing your openness to collaboration! ‚≠ê",
                isEnding: true,
                endingType: "good"
            },
            offerHonor: {
                text: "The Magician nods with respect. 'Your honor is worth more than any deal. You've proven yourself.' He reveals he was the Festival's founder, and the Star was never lost‚Äîthis was a test! He grants you the Star and names you Guardian of the Festival! ‚≠ê",
                isEnding: true,
                endingType: "good"
            },
            // Bad Endings
            demandStar: {
                text: "The sprite's face falls. 'You don't trust me...' She fades away sadly, and the Clock Tower's magic seals itself. Without her help, you search for hours but never find the Star. The Festival is cancelled. Trust must be earned, but also given. ‚ùå",
                isEnding: true,
                endingType: "bad"
            },
            rushCave: {
                text: "You rush past the fox into the glowing cave. The entrance collapses behind you! The 'magic' was a trap set by mischievous sprites. You're stuck in an ice cavern, and the fox‚Äîwho knew the way out‚Äîlimps away. Haste makes waste! ‚ùå",
                isEnding: true,
                endingType: "bad"
            }
        };

        // Calculate responsive game dimensions
        function getGameDimensions() {
            const baseWidth = 800;
            const baseHeight = 600;
            const aspectRatio = baseWidth / baseHeight;
            
            // Get available space
            const maxWidth = Math.min(window.innerWidth - 40, 800); // 20px padding each side
            const maxHeight = Math.min(window.innerHeight - 300, 600); // Account for UI elements
            
            let gameWidth = maxWidth;
            let gameHeight = gameWidth / aspectRatio;
            
            // If height is too large, scale by height instead
            if (gameHeight > maxHeight) {
                gameHeight = maxHeight;
                gameWidth = gameHeight * aspectRatio;
            }
            
            // Ensure minimum size for playability
            const minWidth = 320;
            const minHeight = 240;
            
            gameWidth = Math.max(gameWidth, minWidth);
            gameHeight = Math.max(gameHeight, minHeight);
            
            return {
                width: Math.floor(gameWidth),
                height: Math.floor(gameHeight),
                scale: gameWidth / baseWidth
            };
        }
        
        const gameDimensions = getGameDimensions();
        
        // Phaser Game Configuration
        const config = {
            type: Phaser.AUTO,
            width: gameDimensions.width,
            height: gameDimensions.height,
            parent: 'phaser-game',
            backgroundColor: '#0f3460',
            pixelArt: true,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);
        // Make game globally accessible for mobile controls
        window.game = game;
        
        // Store the scale factor for positioning calculations
        const GAME_SCALE = gameDimensions.scale;

        let player;
        let cursors;
        let currentScene = 'start';
        let portals = [];
        let spaceKey;
        let rKey;
        let snowEmitter;
        
        // Make these globally accessible for mobile controls
        window.player = player;
        window.portals = portals;
        window.spaceKey = spaceKey;

        function preload() {
            // No external assets needed - we'll draw everything programmatically
        }

        function create() {
            const scene = this;

            // Create snowflake texture FIRST
            const graphics = this.make.graphics({ x: 0, y: 0, add: false });
            graphics.fillStyle(0xffffff, 1);
            graphics.fillCircle(4, 4, 4);
            graphics.generateTexture('particle', 8, 8);
            graphics.destroy();

            // Now create snow particle effect
            const particles = this.add.particles(0, 0, 'particle', {
                x: { min: 0, max: 800 },
                y: -20,
                lifespan: 8000,
                speedY: { min: 20, max: 60 },
                speedX: { min: -10, max: 10 },
                scale: { start: 0.3, end: 0.8 },
                alpha: { start: 0.8, end: 0.2 },
                frequency: 100,
                blendMode: 'ADD'
            });

            // Create Christmas Elf Player
            createElfSprite(scene);
            
            // Update global references
            window.player = player;

            // Set up keyboard controls
            cursors = this.input.keyboard.createCursorKeys();
            spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
            
            // Update global references for keyboard
            window.spaceKey = spaceKey;

            // Check for saved game
            const savedGame = saveManager.loadGame();
            console.log('=== CREATE FUNCTION - LOAD CHECK ===');
            console.log('Loaded save game:', savedGame);
            console.log('savedGame exists?', !!savedGame);
            if (savedGame) {
                console.log('savedGame.currentScene:', savedGame.currentScene);
                console.log('Is start scene?', savedGame.currentScene === 'start');
            }
            console.log('====================================');
            
            if (savedGame && savedGame.currentScene !== 'start') {
                console.log('‚úÖ Showing load dialog for scene:', savedGame.currentScene);
                // Show Continue/New Game dialog
                showLoadDialog(scene, savedGame);
            } else {
                console.log('‚ùå No valid save found or save is at start, loading start scene');
                // Load initial scene normally
                loadStoryScene(scene, currentScene);
            }

            // Handle restart
            rKey.on('down', () => {
                restartGame(scene);
            });
        }
        
        function showLoadDialog(scene, savedGame) {
            // Create semi-transparent overlay
            const overlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
            overlay.setDepth(1500);
            overlay.setInteractive();
            
            // Dialog box
            const dialogBox = scene.add.rectangle(400, 300, 500, 300, 0x0f3460, 1);
            dialogBox.setDepth(1501);
            dialogBox.setStrokeStyle(3, 0x4fc3f7);
            
            // Title
            const title = scene.add.text(400, 200, 'üíæ Continue Adventure?', {
                fontSize: '24px',
                fontFamily: 'Courier New',
                color: '#4fc3f7',
                fontStyle: 'bold'
            });
            title.setOrigin(0.5);
            title.setDepth(1502);
            
            // Save info
            const saveInfo = scene.add.text(400, 250, 
                `Last saved at:\n${savedGame.sceneName}\n${saveManager.getTimeSince(savedGame.timestamp)}`, {
                fontSize: '14px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                align: 'center'
            });
            saveInfo.setOrigin(0.5);
            saveInfo.setDepth(1502);
            
            // Continue button
            const continueBtn = createDialogButton(scene, 300, 350, 'Continue', 0x66bb6a, () => {
                // Load saved game
                currentScene = savedGame.currentScene;
                player.setPosition(savedGame.playerPosition.x, savedGame.playerPosition.y);
                loadStoryScene(scene, currentScene);
                closeDialog();
            });
            
            // New Game button
            const newGameBtn = createDialogButton(scene, 500, 350, 'New Game', 0xef5350, () => {
                // Start new game
                saveManager.deleteSave();
                currentScene = 'start';
                player.setPosition(400, 500);
                loadStoryScene(scene, currentScene);
                closeDialog();
            });
            
            function closeDialog() {
                overlay.destroy();
                dialogBox.destroy();
                title.destroy();
                saveInfo.destroy();
                continueBtn.bg.destroy();
                continueBtn.text.destroy();
                newGameBtn.bg.destroy();
                newGameBtn.text.destroy();
            }
        }
        
        function createDialogButton(scene, x, y, text, color, callback) {
            const bg = scene.add.rectangle(x, y, 140, 45, color, 0.8);
            bg.setDepth(1502);
            bg.setStrokeStyle(2, 0xffffff);
            bg.setInteractive();
            
            const label = scene.add.text(x, y, text, {
                fontSize: '16px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                fontStyle: 'bold'
            });
            label.setOrigin(0.5);
            label.setDepth(1503);
            
            // Hover effects
            bg.on('pointerover', () => {
                bg.setFillStyle(color, 1);
                scene.tweens.add({
                    targets: [bg, label],
                    scale: 1.1,
                    duration: 100
                });
            });
            
            bg.on('pointerout', () => {
                bg.setFillStyle(color, 0.8);
                scene.tweens.add({
                    targets: [bg, label],
                    scale: 1,
                    duration: 100
                });
            });
            
            bg.on('pointerdown', callback);
            
            return { bg, text: label };
        }

        function createElfSprite(scene) {
            // Create elf character using graphics
            const elfGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
            
            // Santa Hat (red with white trim)
            elfGraphics.fillStyle(0xdc143c, 1); // Red
            elfGraphics.fillTriangle(8, 2, 16, 16, 0, 16);
            elfGraphics.fillStyle(0xffffff, 1); // White trim
            elfGraphics.fillRect(0, 14, 16, 3);
            elfGraphics.fillCircle(8, 2, 2); // Pompom

            // Face (peach)
            elfGraphics.fillStyle(0xffd4a3, 1);
            elfGraphics.fillCircle(8, 20, 6);
            
            // Eyes
            elfGraphics.fillStyle(0x000000, 1);
            elfGraphics.fillCircle(6, 19, 1);
            elfGraphics.fillCircle(10, 19, 1);
            
            // Rosy cheeks
            elfGraphics.fillStyle(0xff8a80, 0.6);
            elfGraphics.fillCircle(5, 21, 1.5);
            elfGraphics.fillCircle(11, 21, 1.5);

            // Green tunic
            elfGraphics.fillStyle(0x2e7d32, 1);
            elfGraphics.fillRect(2, 26, 12, 12);
            
            // Red belt
            elfGraphics.fillStyle(0xdc143c, 1);
            elfGraphics.fillRect(2, 32, 12, 2);
            
            // Brown boots
            elfGraphics.fillStyle(0x5d4037, 1);
            elfGraphics.fillRect(3, 38, 4, 6);
            elfGraphics.fillRect(9, 38, 4, 6);

            elfGraphics.generateTexture('elf', 16, 44);
            elfGraphics.destroy();

            // Create player sprite
            player = scene.physics.add.sprite(400, 500, 'elf');
            player.setScale(2); // 2x size for better visibility
            player.setCollideWorldBounds(true);
            player.setDepth(1000); // Always on top of everything
        }

        function loadStoryScene(scene, sceneKey) {
            const storyNode = storyData[sceneKey];
            
            // Update story text
            updateStoryText(storyNode.text);
            
            // Clear existing portals
            portals.forEach(portal => {
                portal.sprite.destroy();
                portal.label.destroy();
                if (portal.particles) portal.particles.destroy();
            });
            portals = [];

            if (storyNode.isEnding) {
                // Show ending
                showEnding(scene, storyNode);
            } else {
                // Create portals for choices
                storyNode.portals.forEach(portalData => {
                    createPortal(scene, portalData);
                });
            }
        }

        function createPortal(scene, portalData) {
            // Create portal sprite
            const portalGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
            portalGraphics.fillStyle(portalData.color, 0.8);
            portalGraphics.fillCircle(25, 25, 25);
            portalGraphics.lineStyle(3, 0xffffff, 1);
            portalGraphics.strokeCircle(25, 25, 25);
            portalGraphics.generateTexture('portal_' + portalData.label, 50, 50);
            portalGraphics.destroy();

            const portalSprite = scene.physics.add.sprite(portalData.x, portalData.y, 'portal_' + portalData.label);
            portalSprite.setScale(1.5);
            
            // Add pulsing animation
            scene.tweens.add({
                targets: portalSprite,
                scale: 1.7,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // Create label
            const label = scene.add.text(portalData.x, portalData.y + 60, portalData.label, {
                fontSize: '14px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 8, y: 4 }
            });
            label.setOrigin(0.5);

            // Add glow particles around portal
            const particles = scene.add.particles(portalData.x, portalData.y, 'particle', {
                speed: 20,
                scale: { start: 0.3, end: 0 },
                blendMode: 'ADD',
                lifespan: 1000,
                frequency: 150,
                tint: portalData.color
            });

            portals.push({
                sprite: portalSprite,
                label: label,
                particles: particles,
                next: portalData.next,
                data: portalData
            });
        }

        function showEnding(scene, storyNode) {
            // Create ending overlay
            const overlay = scene.add.rectangle(400, 300, 800, 600, storyNode.endingType === 'good' ? 0x66bb6a : 0xef5350, 0.3);
            
            // Create ending text box
            const endingBox = scene.add.rectangle(400, 300, 600, 300, 0x000000, 0.8);
            endingBox.setStrokeStyle(4, storyNode.endingType === 'good' ? 0x66bb6a : 0xef5350);
            
            const endingTitle = scene.add.text(400, 200, storyNode.endingType === 'good' ? 'üåü SUCCESS! üåü' : 'üíî OH NO! üíî', {
                fontSize: '32px',
                fontFamily: 'Courier New',
                color: storyNode.endingType === 'good' ? '#66bb6a' : '#ef5350',
                fontStyle: 'bold'
            });
            endingTitle.setOrigin(0.5);

            const endingText = scene.add.text(400, 300, storyNode.text, {
                fontSize: '16px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                align: 'center',
                wordWrap: { width: 550 }
            });
            endingText.setOrigin(0.5);

            const restartText = scene.add.text(400, 420, 'Press R to Restart', {
                fontSize: '18px',
                fontFamily: 'Courier New',
                color: '#81d4fa',
                fontStyle: 'bold'
            });
            restartText.setOrigin(0.5);

            // Add to portals array for cleanup
            portals.push({ sprite: overlay, label: endingBox }, { sprite: endingTitle, label: endingText }, { sprite: restartText, label: scene.add.text(0, 0, '') });
        }

        // Global portal auto-enter tracking
        let globalPortalTimeout = null;
        let globalNearPortal = null;

        function update() {
            if (!player) return;

            const scene = this;

            // Player movement
            const speed = 150;
            
            if (cursors.left.isDown) {
                player.setVelocityX(-speed);
            } else if (cursors.right.isDown) {
                player.setVelocityX(speed);
            } else {
                player.setVelocityX(0);
            }

            if (cursors.up.isDown) {
                player.setVelocityY(-speed);
            } else if (cursors.down.isDown) {
                player.setVelocityY(speed);
            } else {
                player.setVelocityY(0);
            }

            // Check portal collisions with auto-enter
            let closestPortal = null;
            let closestDistance = Infinity;
            
            portals.forEach(portal => {
                if (portal.sprite && portal.next) {
                    const distanceToSprite = Phaser.Math.Distance.Between(
                        player.x, player.y,
                        portal.sprite.x, portal.sprite.y
                    );
                    
                    // Also check distance to label text
                    const distanceToLabel = Phaser.Math.Distance.Between(
                        player.x, player.y,
                        portal.label.x, portal.label.y
                    );
                    
                    // Use the closer of the two distances
                    const distance = Math.min(distanceToSprite, distanceToLabel);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPortal = portal;
                    }

                    if (distance < 60) {
                        // Player is near portal - show interaction hint
                        if (!portal.hintShown) {
                            portal.label.setStyle({ backgroundColor: '#4fc3f7' });
                            portal.hintShown = true;
                        }

                        // Check for space key press (still works!)
                        if (Phaser.Input.Keyboard.JustDown(spaceKey)) {
                            console.log('Entering portal (space key):', portal.next);
                            // Clear any auto-enter timeout
                            if (globalPortalTimeout) {
                                clearTimeout(globalPortalTimeout);
                                globalPortalTimeout = null;
                            }
                            globalNearPortal = null;
                            enterPortal(scene, portal.next);
                        }
                    } else {
                        if (portal.hintShown) {
                            portal.label.setStyle({ backgroundColor: '#000000' });
                            portal.hintShown = false;
                        }
                    }
                }
            });
            
            // Auto-enter portal logic (works for everyone!)
            // Increased trigger distance to 50px to account for label size
            if (closestDistance < 50 && closestPortal && closestPortal.next) {
                if (globalNearPortal !== closestPortal.next) {
                    // New portal approached
                    globalNearPortal = closestPortal.next;
                    
                    // Clear any existing timeout
                    if (globalPortalTimeout) {
                        clearTimeout(globalPortalTimeout);
                    }
                    
                    // Set timeout to auto-enter portal after ~0.53 seconds
                    globalPortalTimeout = setTimeout(() => {
                        if (globalNearPortal && closestPortal && closestPortal.next === globalNearPortal) {
                            console.log('Auto-entering portal:', globalNearPortal);
                            enterPortal(scene, globalNearPortal);
                            globalNearPortal = null;
                            globalPortalTimeout = null;
                        }
                    }, 533); // ~0.53 second delay (reduced by 1/3)
                }
            } else if (closestDistance >= 70) {
                // Moved away from portal
                if (globalPortalTimeout) {
                    clearTimeout(globalPortalTimeout);
                    globalPortalTimeout = null;
                }
                if (globalNearPortal) {
                    globalNearPortal = null;
                }
            }
        }

        function enterPortal(scene, nextSceneKey) {
            currentScene = nextSceneKey;
            
            // Auto-save progress
            saveManager.saveGame(nextSceneKey, player.x, player.y);
            showSaveNotification(scene);
            
            // Update save info UI if it exists (Settings menu might be open)
            if (typeof updateSaveInfo === 'function') {
                updateSaveInfo();
            }
            
            // Reset player position
            player.setPosition(400, 500);
            player.setVelocity(0, 0);
            
            // Load new scene
            loadStoryScene(scene, nextSceneKey);
        }
        
        function showSaveNotification(scene) {
            // Create save notification
            const saveText = scene.add.text(700, 30, 'üíæ Saved!', {
                fontSize: '16px',
                fontFamily: 'Courier New',
                color: '#66bb6a',
                backgroundColor: '#000000',
                padding: { x: 10, y: 5 }
            });
            saveText.setDepth(2000);
            saveText.setAlpha(0);
            
            // Fade in and out
            scene.tweens.add({
                targets: saveText,
                alpha: 1,
                duration: 300,
                yoyo: true,
                hold: 1500,
                onComplete: () => {
                    saveText.destroy();
                }
            });
        }

        function restartGame(scene) {
            console.log('=== restartGame() called - NOT deleting save ===');
            currentScene = 'start';
            player.setPosition(400, 500);
            player.setVelocity(0, 0);
            // NOTE: We do NOT delete the save on restart
            // User can explicitly delete via Settings menu if desired
            // Or click "New Game" on the Continue dialog
            loadStoryScene(scene, 'start');
        }

        function updateStoryText(text) {
            const storyTextElement = document.getElementById('story-text');
            storyTextElement.textContent = text;
        }
    </script>

    <!-- Background Music System -->
    <script>
        // Winter Festival Music System with Web Audio API
        class WinterMusicPlayer {
            constructor() {
                this.audioContext = null;
                this.masterGainNode = null;
                this.isPlaying = false;
                this.currentNoteIndex = 0;
                this.intervalId = null;
                this.volume = 0.7;
                
                // Festive winter melody - "Jingle Bells" inspired
                // Notes: C4, D4, E4, F4, G4, A4, B4, C5
                this.melody = [
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.5 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.5 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'G4', duration: 0.25 },
                    { note: 'C4', duration: 0.25 },
                    { note: 'D4', duration: 0.25 },
                    { note: 'E4', duration: 1 },
                    
                    { note: 'F4', duration: 0.25 },
                    { note: 'F4', duration: 0.25 },
                    { note: 'F4', duration: 0.25 },
                    { note: 'F4', duration: 0.25 },
                    { note: 'F4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'D4', duration: 0.25 },
                    { note: 'D4', duration: 0.25 },
                    { note: 'E4', duration: 0.25 },
                    { note: 'D4', duration: 0.5 },
                    { note: 'G4', duration: 0.5 },
                ];
                
                // Note frequencies in Hz
                this.noteFrequencies = {
                    'C4': 261.63,
                    'D4': 293.66,
                    'E4': 329.63,
                    'F4': 349.23,
                    'G4': 392.00,
                    'A4': 440.00,
                    'B4': 493.88,
                    'C5': 523.25
                };
                
                this.initAudioContext();
                this.loadPreferences();
            }
            
            initAudioContext() {
                // Create audio context on first user interaction
          if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGainNode = this.audioContext.createGain();
                    this.masterGainNode.connect(this.audioContext.destination);
                    this.masterGainNode.gain.value = this.volume;
                }
            }
            
            playNote(frequency, duration) {
                if (!this.audioContext || !this.isPlaying) return;
                
                const now = this.audioContext.currentTime;
                
                // Create oscillator for the note
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Use a softer sine wave for a bell-like sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, now);
                
                // Envelope for natural sound (ADSR)
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack
                gainNode.gain.exponentialRampToValueAtTime(0.2, now + 0.1); // Decay
                gainNode.gain.setValueAtTime(0.2, now + duration - 0.1); // Sustain
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration); // Release
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGainNode);
                
                oscillator.start(now);
                oscillator.stop(now + duration);
            }
            
            playMelody() {
                if (!this.isPlaying || this.currentNoteIndex >= this.melody.length) {
                    this.currentNoteIndex = 0; // Loop melody
                    if (!this.isPlaying) return;
                }
                
                const currentNote = this.melody[this.currentNoteIndex];
                const frequency = this.noteFrequencies[currentNote.note];
                
                this.playNote(frequency, currentNote.duration);
                
                this.currentNoteIndex++;
                
                // Schedule next note
                const nextDelay = currentNote.duration * 1000; // Convert to milliseconds
                setTimeout(() => this.playMelody(), nextDelay);
            }
            
            start() {
                if (this.isPlaying) return;
                
                this.initAudioContext();
                
                // Resume audio context (needed for some browsers)
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                this.isPlaying = true;
                this.currentNoteIndex = 0;
                this.playMelody();
                this.savePreferences();
            }
            
            stop() {
                this.isPlaying = false;
                this.currentNoteIndex = 0;
                this.savePreferences();
            }
            
            setVolume(value) {
                this.volume = value;
                if (this.masterGainNode) {
                    this.masterGainNode.gain.value = value;
                }
                this.savePreferences();
            }
            
            savePreferences() {
                localStorage.setItem('winterFestivalMusicPlaying', this.isPlaying);
                localStorage.setItem('winterFestivalMusicVolume', this.volume);
            }
            
            loadPreferences() {
                const savedPlaying = localStorage.getItem('winterFestivalMusicPlaying');
                const savedVolume = localStorage.getItem('winterFestivalMusicVolume');
                
                if (savedVolume !== null) {
                    this.volume = parseFloat(savedVolume);
                }
                
                // Don't auto-play on load, let user start music
                this.isPlaying = false;
            }
        }
        
        // Initialize music player
        const musicPlayer = new WinterMusicPlayer();
        
        // UI Elements
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const toggleButton = document.getElementById('toggle-music');
        const playIcon = document.getElementById('play-icon');
        const musicStatus = document.getElementById('music-status');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeValue = document.getElementById('volume-value');
        const musicIcon = document.getElementById('music-icon');
        
        // Set initial volume from saved preferences
        volumeSlider.value = Math.round(musicPlayer.volume * 100);
        volumeValue.textContent = Math.round(musicPlayer.volume * 100) + '%';
        
        // Settings Menu Toggle
        let settingsOpen = false;
        
        settingsToggle.addEventListener('click', () => {
            settingsOpen = !settingsOpen;
            if (settingsOpen) {
                settingsPanel.classList.add('open');
                settingsToggle.classList.add('active');
            } else {
                settingsPanel.classList.remove('open');
                settingsToggle.classList.remove('active');
            }
        });
        
        // Close settings when clicking outside
        document.addEventListener('click', (e) => {
            const settingsMenu = document.getElementById('settings-menu');
            if (settingsOpen && !settingsMenu.contains(e.target)) {
                settingsPanel.classList.remove('open');
                settingsToggle.classList.remove('active');
                settingsOpen = false;
            }
        });
        
        // Toggle music playback
        function toggleMusic() {
            if (musicPlayer.isPlaying) {
                musicPlayer.stop();
                playIcon.textContent = '‚ñ∂Ô∏è';
                musicStatus.textContent = 'Play';
                toggleButton.classList.remove('playing');
                musicIcon.classList.remove('music-indicator');
            } else {
                musicPlayer.start();
                playIcon.textContent = '‚è∏Ô∏è';
                musicStatus.textContent = 'Pause';
                toggleButton.classList.add('playing');
                musicIcon.classList.add('music-indicator');
            }
        }
        
        // Event Listeners
        toggleButton.addEventListener('click', toggleMusic);
        
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            musicPlayer.setVolume(volume);
            volumeValue.textContent = e.target.value + '%';
        });
        
        // Keyboard shortcut: M key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                // Don't trigger if typing in an input field
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    toggleMusic();
                }
            }
        });
        
        // Save/Load UI Management
        const saveInfoElement = document.getElementById('save-info');
        const deleteSaveButton = document.getElementById('delete-save');
        
        function updateSaveInfo() {
            console.log('=== updateSaveInfo called ===');
            console.log('window.saveManager exists?', !!window.saveManager);
            console.log('saveManager exists?', typeof saveManager !== 'undefined');
            
            // Use window.saveManager to ensure we're accessing the global instance
            const savedGame = window.saveManager ? window.saveManager.loadGame() : null;
            console.log('Loaded save data:', savedGame);
            
            if (savedGame) {
                saveInfoElement.innerHTML = `Saved at:<br>${savedGame.sceneName}<br><span style="color: #4fc3f7;">${window.saveManager.getTimeSince(savedGame.timestamp)}</span>`;
                deleteSaveButton.style.display = 'flex';
            } else {
                saveInfoElement.textContent = 'No save data';
                deleteSaveButton.style.display = 'none';
            }
        }
        
        deleteSaveButton.addEventListener('click', () => {
            if (confirm('Delete your save data? This cannot be undone!')) {
                saveManager.deleteSave();
                updateSaveInfo();
                
                // Show notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: rgba(239, 83, 80, 0.95);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 10px;
                    font-family: 'Courier New', monospace;
                    font-size: 0.9rem;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10000;
                    animation: slideInRight 0.5s ease-out;
                `;
                notification.textContent = 'üóëÔ∏è Save deleted!';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.5s ease-in';
                    setTimeout(() => notification.remove(), 500);
                }, 2000);
            }
        });
        
        // Update save info when settings menu opens
        settingsToggle.addEventListener('click', () => {
            if (!settingsOpen) {
                updateSaveInfo();
            }
        });
        
        // Initial save info update
        updateSaveInfo();
        
        // Show a small notification on first load
        if (!localStorage.getItem('winterFestivalMusicNotificationShown')) {
            setTimeout(() => {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: rgba(79, 195, 247, 0.95);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 10px;
                    font-family: 'Courier New', monospace;
                    font-size: 0.9rem;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10000;
                    animation: slideInRight 0.5s ease-out;
                `;
                notification.innerHTML = '‚öôÔ∏è Click settings (top-right) for music!';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.5s ease-in';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
                
                localStorage.setItem('winterFestivalMusicNotificationShown', 'true');
            }, 2000);
        }
        
        // Add animation keyframes
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    
    <!-- Mobile Touch Controls Script -->
    <script>
        // Mobile touch control state
        const mobileControls = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        
        let portalProximityTimeout = null;
        let nearPortal = null;
        
        // Get mobile control buttons
        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnRestart = document.getElementById('mobile-restart');
        const portalHint = document.getElementById('portal-hint');
        
        // Function to handle touch start
        function handleTouchStart(direction) {
            return (e) => {
                e.preventDefault();
                mobileControls[direction] = true;
                e.target.classList.add('active');
            };
        }
        
        // Function to handle touch end
        function handleTouchEnd(direction) {
            return (e) => {
                e.preventDefault();
                mobileControls[direction] = false;
                e.target.classList.remove('active');
            };
        }
        
        // Add touch event listeners to D-pad buttons
        ['touchstart', 'mousedown'].forEach(eventType => {
            btnUp.addEventListener(eventType, handleTouchStart('up'));
            btnDown.addEventListener(eventType, handleTouchStart('down'));
            btnLeft.addEventListener(eventType, handleTouchStart('left'));
            btnRight.addEventListener(eventType, handleTouchStart('right'));
        });
        
        ['touchend', 'mouseup', 'touchcancel'].forEach(eventType => {
            btnUp.addEventListener(eventType, handleTouchEnd('up'));
            btnDown.addEventListener(eventType, handleTouchEnd('down'));
            btnLeft.addEventListener(eventType, handleTouchEnd('left'));
            btnRight.addEventListener(eventType, handleTouchEnd('right'));
        });
        
        // Mobile restart button
        ['touchstart', 'click'].forEach(eventType => {
            btnRestart.addEventListener(eventType, (e) => {
                e.preventDefault();
                // Trigger R key press for restart
                const rKeyEvent = new KeyboardEvent('keydown', { key: 'r', keyCode: 82 });
                document.dispatchEvent(rKeyEvent);
            });
        });
        
        // Integrate mobile controls with Phaser game loop
        // Apply mobile control velocities every frame
        setInterval(() => {
            if (!window.player) return;
            
            // Only apply mobile controls if any mobile button is pressed
            // Otherwise, let the keyboard controls in update() handle movement
            if (mobileControls.up || mobileControls.down || mobileControls.left || mobileControls.right) {
                const speed = 150;
                let velocityX = 0;
                let velocityY = 0;
                
                // Calculate velocity based on which buttons are pressed
                if (mobileControls.left) velocityX = -speed;
                if (mobileControls.right) velocityX = speed;
                if (mobileControls.up) velocityY = -speed;
                if (mobileControls.down) velocityY = speed;
                
                // Set velocity for mobile controls
                window.player.setVelocity(velocityX, velocityY);
            }
            // If no mobile controls pressed, do nothing - let keyboard handle it
            
        }, 1000 / 60); // 60 FPS
        
        function checkPortalProximityMobile(scene) {
            if (!player || !portals || portals.length === 0) return;
            
            let closestPortal = null;
            let closestDistance = Infinity;
            
            portals.forEach(portal => {
                if (portal.sprite && portal.next) {
                    const distance = Phaser.Math.Distance.Between(
                        player.x, player.y,
                        portal.sprite.x, portal.sprite.y
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPortal = portal;
                    }
                }
            });
            
            // If very close to portal (within 40px), auto-enter after brief delay
            if (closestDistance < 40 && closestPortal && closestPortal.next) {
                if (nearPortal !== closestPortal.next) {
                    // New portal approached
                    nearPortal = closestPortal.next;
                    showPortalHint();
                    
                    // Clear any existing timeout
                    if (portalProximityTimeout) {
                        clearTimeout(portalProximityTimeout);
                    }
                    
                    // Set timeout to auto-enter portal after 0.8 seconds
                    portalProximityTimeout = setTimeout(() => {
                        if (nearPortal && closestPortal && closestPortal.next === nearPortal) {
                            console.log('Auto-entering portal:', nearPortal);
                            // Simulate space key press
                            const spaceEvent = new KeyboardEvent('keydown', { 
                                key: ' ',
                                keyCode: 32,
                                code: 'Space'
                            });
                            document.dispatchEvent(spaceEvent);
                            
                            // Also trigger Phaser's space key directly
                            if (spaceKey && spaceKey.isDown !== undefined) {
                                // Create a manual trigger
                                enterPortal(scene, nearPortal);
                            }
                            
                            hidePortalHint();
                            nearPortal = null;
                            portalProximityTimeout = null;
                        }
                    }, 800); // 0.8 second delay
                }
            } else if (closestDistance >= 70) {
                // Moved away from portal
                if (portalProximityTimeout) {
                    clearTimeout(portalProximityTimeout);
                    portalProximityTimeout = null;
                }
                if (nearPortal) {
                    nearPortal = null;
                    hidePortalHint();
                }
            }
        }
        
        function showPortalHint() {
            if (portalHint) {
                portalHint.classList.add('show');
            }
        }
        
        function hidePortalHint() {
            if (portalHint) {
                portalHint.classList.remove('show');
            }
        }
        
        // Prevent default touch behavior on mobile controls to avoid scrolling
        document.getElementById('mobile-controls').addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        // Hide mobile controls on desktop (additional check)
        function checkIfMobile() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreen = window.innerWidth <= 768;
            
            return isMobile || (isTouchDevice && isSmallScreen);
        }
        
        // Show controls on mobile, hide on desktop
        if (checkIfMobile()) {
            document.getElementById('mobile-controls').style.display = 'flex';
            // Update instructions for mobile
            const instructions = document.querySelector('.instructions');
            if (instructions) {
                instructions.textContent = 'üéÆ Use D-Pad to Move | Walk to Portal to Enter | üîÑ Restart';
            }
        }
    </script>
</body>
</html>
